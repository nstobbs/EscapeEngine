Entity Component System

Entity {ID} - MeshObject, GridObject, BoidObject, CameraObject, Anything
Component {Data} - Transforms, MeshData{Vertices, Indices}, Physics, Shaders, Camera
Systems {Processing} - RenderSystem(MeshData + Shaders + Transforms & CameraInfo), PhysicsSystem(Transforms + Physics), InputSystem(Window Inputs + Transforms)


Programs Design

Classes:
    App:
        Handles the
        Start Up
        MainLoop
        Teardown.
        Takes A Scene as a Inputs and renders it to screen.

    Scene:
        Stores all of the Entities and Component.
        Only Stores One Active CameraComponent.
        std::vector<Entity> Entities;
        CameraComponent ActiveCamera;
        unordered_map<TransformsComponent> TransformsComponents;
        unordered_map<MeshComponent> MeshComponents;
        unordered_map<ShaderComponent> ShaderComponents;
        unordered_map<PhysicsComponent> PhysicsComponents;


Entities;
uint32_t = Entity;

Struct:
    CameraComponent:
        Stores the Camera Data of a Entity;
        vec3 Position;
        vec3 Up;
        vec3 Front;
        float FocalLength;

    TransformsComponent:
        Stores the Position Data of a Entity.
        vec3 or mat4 Position;

    MeshComponent:
        Stores the Mesh Data of a Entity;
        uint32_t VerticesCount;
        std::vector<uint32_t> Vertices;
        std::vector<uint32_t> Indices;

    ShaderComponent:
        Stores the Shader / Material Data of a Entity;
        std::string FragmentFilepath;
        std::string FragmentFilepath;

    PhysicsComponent:
        Stores the Data related to Physics of a Entity.
        In Our case we will be using this Components
        to run our Boids Simulations.
        So storing Data that the PhysicsSystem will
        be using later. 

TODO List:
UniformBuffer
    Decide how I want to handle this. Each shader will also need a
    UniformBuffer for the Model, View, Projections matriex for the Camera and Positions.
    Would be nice if I could add an unquire strct for each shader to be able to pass
    textures and global shader properties.

    When creating the shader, could be a good idea to create an unquire descriptor set and
    layout. Based on connected Components to the shader. Like TextureComponents?

TextureComponent
    Stores the needed information to read a image.
    Will need to add a way to attach a TextureComponent to a ShaderComponent.
    Will also need to add the backend functions for this to work.

CameraSystem
    System for processing the Mouse and Keyboard inputs and transforms the active Camera.
    Mainly in the style of Arcball Camera. Would be nice to be able to switch to different
    camera movement styles like First Person Shooter style camera.

Texture Loader
    Reads an image into the CPU.

Create Basic Shapes
    Functions for creating basic Mesh Objects like Cube, Card, Sphere.

DearImGui
    Need to setup the backend to support DeadImGUI.
    Create an simple UI to manage the Scene Data.
    Scene Tree / Graph.
    Component Editor. Allow editing of Position, Rotations of Meshes.
    Debug Overlays. FPS, Frametimes, CameraPosition.

Compute
    Look into how to get the compute pipeline working
    and thinking about using it for the boids Physics
    system. 


Descriptors Plan

1. Create Descriptors Layouts
2. Tell the GraphicPipeline What our Layout looks like
3. Create a Descriptors Pool based off the Size of the Descriptors Sets Layout. 
    This will be used to allocate memory for our Shader?? i think...
4. Then we create the actual Descriptors Sets to be used in the Shader.
    I believe at this point we actual point the Descriptors Sets to the
    data to use as well.

Need a function to create descriptor layouts based
ofd data we want to find it. e.g. Different uniformBuffers like camera transformations,
model transformations, global lighting values, texture samplers, ...

Descriptors pools. I don't really understand this part at all.

Split With Common, Model, Shader?

SceneUniformBuffer <-----> Set 0
vec3 view
vec3 proj
sampler _sampler

ObjectUniformBuffer <-----> Set 1
vec3 modelTransforms
...

TextureUniformBuffer <-----> Set 2
texture _texture
